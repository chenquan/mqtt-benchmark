use std::sync::Arc;

use awaitgroup::WaitGroup;
use clap::Parser;
use rumqttc::{AsyncClient, MqttOptions, QoS};
use tokio::sync::Mutex;
use url::Url;

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let c: Config = Config::parse();
    println!("{:?}", c);

    let benchmark = Benchmark::new(c);
    benchmark.run().await;
}

#[derive(Clone, Debug, Parser)]
#[clap(version = "0.1.1", author = "chen quan <chenquan.dev@gmail.com>")]
#[command(name = "mqtt-benchmark")]
#[command(about = "A simple MQTT (broker) benchmarking tool.", long_about = None)]
struct Config {
    /// MQTT client id
    #[arg(short, long, default_value = "mqtt-benchmark")]
    client_id: String,
    /// MQTT broker
    #[arg(short, long, default_value = "127.0.0.1:1883")]
    broker: String,
    /// MQTT topic
    #[arg(short, long, default_value = "test")]
    topic: String,
    /// MQTT username
    #[arg(short, long)]
    username: Option<String>,
    /// MQTT password
    #[arg(short, long)]
    password: Option<String>,
    /// MQTT qos
    #[arg(short, long, default_value_t = 1)]
    qos: i32,
    #[arg(short, long, default_value_t = false)]
    /// Only one topic is sent data
    one_topic: bool,
    /// MQTT payload, allowed to be empty
    #[arg(short = 'P', long)]
    payload: Option<String>,
    /// The number of data entries generated by each client
    #[arg(short, long, default_value_t = 10000)]
    size: usize,

    /// The number of MQTT clients that are created
    #[arg(short = 'C', long, default_value_t = 10)]
    client_num: usize,
}

struct Mqtt {
    c: Config,
}

#[derive(Clone, Debug)]
struct Stat {
    cli: usize,
    num: i64,
    duration: time::Duration,
}

fn to_qos(qos: i32) -> QoS {
    match qos {
        0 => QoS::AtMostOnce,
        1 => QoS::AtLeastOnce,
        2 => QoS::ExactlyOnce,
        _ => panic!("invalid qos"),
    }
}

impl From<Config> for MqttOptions {
    fn from(value: Config) -> Self {
        let url_str = format!("tcp://{}", value.broker);
        let url = Url::parse(&url_str).expect("invalid broker address");
        let port = url.port().expect("invalid broker port");
        let host = url.domain().expect("invalid broker host");

        MqttOptions::new(value.client_id, host, port)
    }
}

impl Mqtt {
    fn new(c: Config) -> Self {
        Mqtt { c }
    }

    async fn do_benchmark(&self, client_num: usize) -> Option<Stat> {
        let (client, mut event_loop) = AsyncClient::new(self.c.clone().into(), 10);

        let start = time::Instant::now();
        tokio::spawn(async move {
            loop {
                let event = event_loop.poll().await;
                match &event {
                    Ok(_) => {}
                    Err(_) => return,
                }
            }
        });

        let mut i = 0usize;
        loop {
            if i >= self.c.size {
                break;
            }

            let mut payload: Vec<u8> = Vec::new();
            if let Some(data) = &self.c.payload {
                payload.extend(data.as_bytes());
            };

            let result = client.publish(&self.c.topic, to_qos(self.c.qos), false, payload);
            if let Err(err) = result.await {
                println!("client: {}, publish failed:{}", client_num, err);
                break;
            }

            i += 1
        }

        let duration = start.elapsed();
        if let Err(err) = client.disconnect().await {
            println!("client: {}, disconnect failed:{}", client_num, err);
        }

        let speed = (i as f64) / duration.as_seconds_f64();
        let stat = Stat {
            cli: client_num,
            num: i as i64,
            duration,
        };

        println!(
            "client: {:}, num: {}, duration: {:.4} (sec), speed: {:.4} (msg/sec)",
            stat.cli,
            stat.num,
            stat.duration.as_seconds_f64(),
            speed
        );

        Some(stat)
    }
}

// ----------------

struct Benchmark {
    config: Config,
}

impl Benchmark {
    fn new(config: Config) -> Self {
        Benchmark { config }
    }

    async fn run(&self) {
        let mut wg = WaitGroup::new();
        let clients = self.init_conn().await;
        println!("{}", "=".repeat(30));
        let clients = Arc::new(clients);

        let stats = Arc::new(Mutex::new(Vec::<Stat>::new()));
        let start = time::Instant::now();

        for i in 0..self.config.client_num {
            let worker = wg.worker();
            let stats = stats.clone();
            let clients = clients.clone();

            tokio::spawn(async move {
                if let Some(client) = clients.get(i) {
                    let stat_op = client.do_benchmark(i).await;
                    let mut stats = stats.lock().await;
                    if let Some(stat) = stat_op {
                        stats.push(stat);
                    }
                }
                worker.done();
            });
        }
        wg.wait().await;

        let guard = stats.lock().await;
        let mut num = 0i64;
        let duration = start.elapsed();

        for x in guard.iter() {
            num += x.num;
        }
        println!("{}", "=".repeat(30));

        println!(
            "{} client, total: {}, duration: {:.4} (sec), avg speed: {:.4} (msg/sec)",
            self.config.client_num,
            num,
            duration.as_seconds_f64(),
            (num as f64) / duration.as_seconds_f64()
        );
    }

    async fn init_conn(&self) -> Vec<Arc<Mqtt>> {
        let mut clients = vec![];
        for i in 0..self.config.client_num {
            let mut config = self.config.clone();
            config.client_id = format!("{}_{}", config.client_id, i);
            if !self.config.one_topic {
                config.topic = format!("{}/{}", config.topic, i);
            }

            let mqtt = Arc::new(Mqtt::new(config));
            clients.push(mqtt.clone());
        }
        clients
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn client() {
        let mqtt = Mqtt::new(Config {
            client_id: "x".to_string(),
            broker: "localhost:1883".to_string(),
            topic: "iot/".to_string(),
            one_topic: false,
            username: None,
            password: None,
            qos: 1,
            payload: Some("1".to_string()),
            size: 100,
            client_num: 0,
        });
        mqtt.do_benchmark(1).await;
    }

    #[tokio::test]
    async fn benchmark() {
        let benchmark = Benchmark::new(Config {
            client_id: "x".to_string(),
            broker: "localhost:1883".to_string(),
            topic: "iot/".to_string(),
            one_topic: false,
            username: None,
            password: None,
            qos: 1,
            payload: Some("1".to_string()),
            size: 100,
            client_num: 0,
        });
        benchmark.run().await
    }
}
