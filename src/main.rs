use std::sync::Arc;
use std::time::Duration;

use awaitgroup::WaitGroup;
use clap::Parser;
use paho_mqtt::{CreateOptions, CreateOptionsBuilder};
use tokio::sync::Mutex;

#[tokio::main(flavor = "multi_thread", worker_threads = 1000)]
async fn main() {
    let c: Config = Config::parse();
    println!("{:?}", c);

    let benchmark = Benchmark::new(c);
    benchmark.run().await;
}

#[derive(Clone, Debug, Parser)]
#[clap(version = "0.1.1", author = "chen quan <chenquan.dev@gmail.com>")]
#[command(name = "mqtt-benchmark")]
#[command(about = "A simple MQTT (broker) benchmarking tool.", long_about = None)]
struct Config {
    /// MQTT client id
    #[arg(short, long, default_value = "mqtt-benchmark")]
    client_id: String,
    /// MQTT broker
    #[arg(short, long, default_value = "localhost:1883")]
    broker: String,
    /// MQTT topic
    #[arg(short, long, default_value = "test")]
    topic: String,
    /// MQTT username
    #[arg(short, long)]
    username: Option<String>,
    /// MQTT password
    #[arg(short, long)]
    password: Option<String>,
    /// MQTT qos
    #[arg(short, long, default_value_t = 1)]
    qos: i32,
    /// MQTT payload, allowed to be empty
    #[arg(short = 'P', long)]
    payload: Option<String>,
    /// The number of data entries generated by each client
    #[arg(short, long, default_value_t = 100)]
    size: usize,

    /// The number of MQTT clients that are created
    #[arg(short = 'C', long, default_value_t = 10)]
    client_num: usize,
}

struct Mqtt {
    client: paho_mqtt::Client,
    c: Config,
}

#[derive(Clone, Debug)]
struct Stat {
    cli: usize,
    num: i64,
    duration: time::Duration,
}

impl From<&Config> for CreateOptions {
    fn from(value: &Config) -> Self {
        let builder = CreateOptionsBuilder::new();
        builder
            .client_id(&value.client_id)
            .server_uri(&value.broker)
            .finalize()
    }
}

impl Mqtt {
    fn new(c: Config) -> Self {
        Mqtt {
            client: paho_mqtt::Client::new(&c).unwrap(),
            c,
        }
    }

    async fn init_conn(&self) -> bool {
        let mut connect_opts_builder = paho_mqtt::ConnectOptionsBuilder::new();
        connect_opts_builder
            .keep_alive_interval(Duration::from_secs(60))
            .automatic_reconnect(Duration::from_secs(1), Duration::from_secs(60))
            .clean_session(true);

        if let Some(username) = &self.c.username {
            connect_opts_builder.user_name(username.clone());
        }
        if let Some(password) = &self.c.password {
            connect_opts_builder.password(password.clone());
        }
        let connect_opts = connect_opts_builder.finalize();

        let result = self.client.connect(connect_opts);
        result.is_ok()
    }

    async fn do_benchmark(&self, client_num: usize) -> Option<Stat> {
        let start = time::Instant::now();
        let mut i = 0usize;
        while self.client.is_connected() {
            let mut msg_builder = paho_mqtt::MessageBuilder::new()
                .topic(&self.c.topic)
                .qos(self.c.qos);

            if let Some(data) = &self.c.payload {
                msg_builder = msg_builder.payload(data.as_bytes());
            }
            let message = msg_builder.finalize();
            if let Err(err) = self.client.publish(message) {
                println!("client: {}, publish failed:{}", client_num, err);
            }

            if i >= self.c.size {
                break;
            }

            i += 1
        }

        let duration = start.elapsed();
        if self.client.is_connected() {
            if let Err(err) = self.client.disconnect_after(Duration::from_secs(1)) {
                println!("client: {}, disconnect failed:{}", client_num, err);
            }
        } else {
            println!("client: {}, connection is closed earl.", client_num);
            return None;
        }

        let speed = (i as f64) / duration.as_seconds_f64();
        let stat = Stat {
            cli: client_num,
            num: i as i64,
            duration,
        };

        println!(
            "client: {:}, num: {}, duration: {:.4} (sec), speed: {:.4} (msg/sec)",
            stat.cli,
            stat.num,
            stat.duration.as_seconds_f64(),
            speed
        );

        Some(stat)
    }
}

// ----------------

struct Benchmark {
    config: Config,
}

impl Benchmark {
    fn new(config: Config) -> Self {
        Benchmark { config }
    }

    async fn run(&self) {
        let mut wg = WaitGroup::new();
        let clients = self.init_conn().await;
        println!("{}", "=".repeat(30));
        let clients = Arc::new(clients);

        let stats = Arc::new(Mutex::new(Vec::<Stat>::new()));
        let start = time::Instant::now();

        for i in 0..self.config.client_num {
            let worker = wg.worker();
            let stats = stats.clone();
            let clients = clients.clone();

            tokio::spawn(async move {
                if let Some(client) = clients.get(i) {
                    let stat_op = client.do_benchmark(i).await;
                    let mut stats = stats.lock().await;
                    if let Some(stat) = stat_op {
                        stats.push(stat);
                    }
                }
                worker.done();
            });
        }
        wg.wait().await;

        let guard = stats.lock().await;
        let mut num = 0i64;
        let duration = start.elapsed();

        for x in guard.iter() {
            num += x.num;
        }
        println!("{}", "=".repeat(30));

        println!(
            "{} client, total: {}, duration: {:.4} (sec), avg speed: {:.4} (msg/sec)",
            self.config.client_num,
            num,
            duration.as_seconds_f64(),
            (num as f64) / duration.as_seconds_f64()
        );
    }

    async fn init_conn(&self) -> Vec<Arc<Mqtt>> {
        println!("init client connection");

        let start = time::Instant::now();

        let mut wg = WaitGroup::new();
        let mut clients = vec![];
        for i in 0..self.config.client_num {
            let worker = wg.worker();
            let mut config = self.config.clone();
            config.client_id = format!("{}_{}", config.client_id, i);
            config.topic = format!("{}/{}", config.topic, i);

            let mqtt = Arc::new(Mqtt::new(config));

            clients.push(mqtt.clone());

            let mqtt = mqtt.clone();
            tokio::spawn(async move {
                if !mqtt.init_conn().await {
                    println!("client: {}, connect failed", i);
                }
                worker.done();
            });
        }
        wg.wait().await;
        let duration = start.elapsed();
        println!(
            "{} client connected. duration: {:4} (sec), speed: {} (client/sec)",
            self.config.client_num,
            duration.as_seconds_f64(),
            self.config.client_num as f64 / duration.as_seconds_f64()
        );
        println!("init client connection finished");

        clients
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn client() {
        let mqtt = Mqtt::new(Config {
            client_id: "x".to_string(),
            broker: "localhost:1883".to_string(),
            topic: "iot/".to_string(),
            username: None,
            password: None,
            qos: 1,
            payload: Some("1".to_string()),
            size: 100,
            client_num: 0,
        });
        mqtt.do_benchmark(1).await;
    }

    #[tokio::test]
    async fn benchmark() {
        let benchmark = Benchmark::new(Config {
            client_id: "x".to_string(),
            broker: "localhost:1883".to_string(),
            topic: "iot/".to_string(),
            username: None,
            password: None,
            qos: 1,
            payload: Some("1".to_string()),
            size: 100,
            client_num: 0,
        });
        benchmark.run().await
    }
}
